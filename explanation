This project takes a set of numbers for a domain and a set of numbers for the codomain and returns a linear relationship if possible, and also a polynomial relationship. This does NOT return the line of best fit and does not have anything to do with statistics. It is mostly a math gimmick but it holds true for any set of unique numbers. 

This project is also not up to industry standard. While it does work, it will not catch a repeat number in the domain, nor does it specifically map each element in the domain to one in the codomain. Rather, it just goes in order, and then disregards the extra numbers at the end. Inputting the numbers is also risky business as if you press enter too many times you will have to rerun the project. It may also be impractical for larger data sets but I could have it read from files. 

As I’ve said before, the functions from this program have no statistical significance and are made by what is essentially the math version of hardcoding the output for every input. There is no extrapolative or interpolative value, at all. Think of it as a piecewise function for each data point, but disguised so it doesn’t look like it. 

Essentially, this program is useless unless you want to prove a point. In that regard, it doesn’t do so well either, because it doesn’t demonstrate that there are multiple polynomials that map any domain to a codomain. It provides ONE polynomial that maps a domain to a codomain, but you also have to assume that there is another one. The best thing to do is to choose a domain and codomain for which the polynomial is easily known. For example, the domain of 1 2 3 4 mapped to 1 4 9 16 clearly looks like f(x) = x^2. My program returns the function 

f(x) =  -4.44089e-16x^3 + 1x^2 + -3.55271e-15x^1 + 0. 

The math behind it is also rather simple. Given a domain D and a codomain C, take each Ci, multiply it by (x - Dj) where j != i, divide by (Di - Dj), then add them all up. Essentially, for each Ci, they have a factor of (x - Dj) which would zero it out if it wasn’t the current i. 

In order to make it look more like an actual function, I had to factor out the (x - D1)(x - D2) … (x - Dn-1) and add them all up. To do this, I used Vieta’s formulas, which relates the roots of any polynomial to the coefficients of each power of x factored out. For example, (x-r1)(x-r2)(x-r3) would look like 

x^3 - (r1+r2+r3)x^2 + (r1r2+ r1r3 + r2r3)x^1 - (r1r2r3)x^0. 

This kind of looks like finding all the subsets of the same size and adding them up. I implemented this by generating binary numbers between 1 and 2^(n-1) where n is min(size of domain, size of codomain). All binary numbers would have leading zeros so, in this case, 1 would be 001. 001 would then translate to r3, 010 to r2, and 100 to r1. 111 would translate to r1*r2*r3. 011 would translate to r2*r3. From this, you can get all the subsets of the roots you need and group them based on the number of zeros (or 1s). Repeat this with each codomain value, add them all up, and you will get the polynomial function. 
